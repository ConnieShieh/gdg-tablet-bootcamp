"""
   includes.py - Javascript includes generator.

   Handles combining scripts and application manifest files.
"""
import os
import logging
import settings
from datetime import datetime

APP_PATH = os.path.dirname(os.path.abspath(__file__))

SCRIPT_INCLUDE = '<script type="text/javascript" src="/js/%s.js?v=%s"></script>'
STYLE_INCLUDE = '<link type="text/css" rel="stylesheet" href="/css/%s.css?v=%s" />'


class App(object):
    all_apps = {}

    def __init__(self, name, scripts=None, styles=None, images=None):
        self.name = name
        self.scripts = scripts or ()
        self.styles = styles or ()
        self.images = images or ()
        self.all_apps[name] = self
        logging.info("Defining application: %s", name)
        self.build_manifest()

    @classmethod
    def get_app(cls, app_name):
        if app_name is None:
            logging.warning("No application defined in template.")
            return data

        if app_name not in cls.all_apps:
            logging.error("No such app: %s.", app_name)

        return cls.all_apps[app_name]

    def get_data(self):
        data = {'scripts': '',
                'styles': '',
                'manifest': '',
                }

        if settings.APPCACHE:
            data['manifest'] = 'manifest="/manifest/%s.appcache"' % self.name

        if len(self.scripts) > 0:
            if settings.COMBINED:
                base_names = ['combined/%s%s' % (self.name, '-min' if settings.MINIFIED else '')]
            else:
                base_names = self.scripts
            data['scripts'] = '\n'.join([SCRIPT_INCLUDE % (name, self.version)
                                         for name in base_names])

        if len(self.styles) > 0:
            if settings.COMBINED:
                data['styles'] = STYLE_INCLUDE % ('combined/' + self.name, self.version)
            else:
                data['styles'] = '\n'.join([STYLE_INCLUDE % (name, self.version)
                                            for name in self.styles])

        return data

    def build_manifest(self):
        self.version = datetime.now().isoformat()
        manifest = ("CACHE MANIFEST\n" +
                    "# %s cache updated: %s" % (self.name, self.version)
                    )

        manifest += "\nNETWORK:\n/\n*\n"

        if settings.APPCACHE:
            manifest += "\n\nCACHE:\n"

            if settings.COMBINED:
                manifest += "/js/combined/%s%s.js?v=%s\n" % (self.name,
                                                             '-min' if settings.MINIFIED else '',
                                                             self.version)
            else:
                for basename in self.scripts:
                    manifest += "/js/%s.js?v=%s\n" % (basename, self.version)

            if settings.COMBINED:
                manifest += "/css/combined/%s.css?v=%s\n" % (self.name, self.version)
            else:
                for basename in self.styles:
                    manifest += "/css/%s.css?v=%s\n" % (basename, self.version)

            for fullname in self.images:
                manifest += '/images/%s\n' % fullname

        self.manifest = manifest

    @classmethod
    def get_paths(cls):
        from google.appengine.ext import webapp

        class ManifestHandler(webapp.RequestHandler):
            def get(self, app_name):
                app = App.all_apps.get(app_name)
                if app is None:
                    self.error(404)
                    self.response.out.write("No such application: %s" % app_name)
                    return

                self.response.headers['Content-Type'] = 'text/cache-manifest'
                self.response.out.write(app.manifest)

        return [('/manifest/(\w+).appcache', ManifestHandler)]




def update_manifest(explicit=False):
    """
    Update the manifest file AUTOGENERATED secion.  We do this on
    each application upload in case any files have changed that
    require a new manifest file be written.
    """
    if not os.path.exists(MANIFEST_FILENAME):
        return

    manifest_file = open(MANIFEST_FILENAME, 'r')
    parts = manifest_file.read().partition('\n' + AUTOGEN_LINE)
    manifest_file.close()
    if parts[1] == '':
        if explicit:
            print "%s has no AUTOGENERATE section" % MANIFEST_FILENAME
        return

    commands = [line for line in parts[2].split('\n') if line.startswith('#!')]
    excludes = []
    for command in commands:
        match = re.match(r'#!\s*EXCLUDE:\s*(.*)\s*$', command)
        if options.verbose:
            print "Excluding paths beginning with '%s'" % match.group(1)
        if match:
            excludes.extend(re.split(r",\s*", match.group(1)))

    cached_files = []
    hash_lines = []

    paths = options.local_listing.keys()
    paths.sort()
    size = 0
    for path in paths:
        info = options.local_listing[path]
        if path == MANIFEST_FILENAME or path == META_FILENAME or \
            info['size'] > MAX_FILE_SIZE or \
            is_data_path(path) or \
            prefix_match(excludes, path):
            continue
        cached_files.append(path)
        hash_lines.append("%s=%s" % (path, info['sha1']))
        size += info['size']

    manifest_lines = [parts[0], AUTOGEN_LINE, AUTOGEN_EXPLAIN]
    manifest_lines.extend(commands)
    manifest_lines.extend((
            "# TOTAL FILES: %s (%s bytes)" % (intcomma(len(cached_files)), intcomma(size)),
            "# SIGNATURE: %s" % hashlib.sha1('\n'.join(hash_lines)).hexdigest(),
            "CACHE:",
            ))
    manifest_lines.extend(cached_files)

    manifest_file = open(MANIFEST_FILENAME, 'w')
    manifest_file.write('\n'.join(manifest_lines) + '\n')
    manifest_file.close()

    # Make sure the listing for the manifest file is up to date
    # so it will be uploaded if changed.
    update_local_listing(MANIFEST_FILENAME)


