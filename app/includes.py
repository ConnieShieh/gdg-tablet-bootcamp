"""
   includes.py - Javascript includes generator.

   Handles combining scripts and application manifest files.
"""
import os
import logging
import settings
from datetime import datetime

from google.appengine.ext import webapp

APP_PATH = os.path.dirname(os.path.abspath(__file__))

SCRIPT_INCLUDE = '<script type="text/javascript" src="/js/%s.js"></script>'
STYLE_INCLUDE = '<link type="text/css" rel="stylesheet" href="/css/%s.css" />'


class App(object):
    all_apps = {}

    def __init__(self, name, scripts=None, styles=None, images=None):
        self.name = name
        self.scripts = scripts or ()
        self.styles = styles or ()
        self.images = images or ()
        self.all_apps[name] = self
        logging.info("Defining application: %s", name)
        self.build_manifest()

    @classmethod
    def get_app_data(cls, app_name):
        data = {'scripts': '',
                'styles': '',
                'manifest': '',
                }
        if app_name is None:
            logging.warning("No application defined in template.")
            return data

        if app_name not in cls.all_apps:
            logging.error("No such app: %s.", app_name)

        app = cls.all_apps[app_name]

        if len(app.scripts) > 0:
            if settings.COMBINED:
                base_names = ['%s-combined' % app_name]
            else:
                base_names = app.scripts
            data['scripts'] = '\n'.join([SCRIPT_INCLUDE % name for name in base_names])

        if len(app.styles) > 0:
            data['styles'] = '\n'.join([STYLE_INCLUDE % name for name in app.styles])

        data['manifest'] = 'manifest="/manifest/%s.appcache"' % app_name if settings.APPCACHE else ''
        return data

    def build_manifest(self):
        manifest = ("CACHE MANIFEST\n" +
                    "# %s cache updated: %s" % (self.name, datetime.now().isoformat())
                    )

        manifest += "\n\nCACHE:\n"

        for basename in self.scripts:
            manifest += "/js/%s.js\n" % basename

        for basename in self.styles:
            manifest += "/css/%s.css\n" % basename

        for fullname in self.images:
            manifest += '/images/%s\n' % fullname

        manifest += "\nNETWORK:\n/data\n/data/*\n"

        self.manifest = manifest
        logging.info(manifest)

    @classmethod
    def get_paths(cls):
        return [('/manifest/(\w+).appcache', ManifestHandler)]


class ManifestHandler(webapp.RequestHandler):
    def get(self, app_name):
        app = App.all_apps.get(app_name)
        if app is None:
            self.error(404)
            self.response.out.write("No such application: %s" % app_name)
            return

        self.response.headers['Content-Type'] = 'test/cache-manifest'
        self.response.out.write(app.manifest)


def update_manifest(explicit=False):
    """
    Update the manifest file AUTOGENERATED secion.  We do this on
    each application upload in case any files have changed that
    require a new manifest file be written.
    """
    if not os.path.exists(MANIFEST_FILENAME):
        return

    manifest_file = open(MANIFEST_FILENAME, 'r')
    parts = manifest_file.read().partition('\n' + AUTOGEN_LINE)
    manifest_file.close()
    if parts[1] == '':
        if explicit:
            print "%s has no AUTOGENERATE section" % MANIFEST_FILENAME
        return

    commands = [line for line in parts[2].split('\n') if line.startswith('#!')]
    excludes = []
    for command in commands:
        match = re.match(r'#!\s*EXCLUDE:\s*(.*)\s*$', command)
        if options.verbose:
            print "Excluding paths beginning with '%s'" % match.group(1)
        if match:
            excludes.extend(re.split(r",\s*", match.group(1)))

    cached_files = []
    hash_lines = []

    paths = options.local_listing.keys()
    paths.sort()
    size = 0
    for path in paths:
        info = options.local_listing[path]
        if path == MANIFEST_FILENAME or path == META_FILENAME or \
            info['size'] > MAX_FILE_SIZE or \
            is_data_path(path) or \
            prefix_match(excludes, path):
            continue
        cached_files.append(path)
        hash_lines.append("%s=%s" % (path, info['sha1']))
        size += info['size']

    manifest_lines = [parts[0], AUTOGEN_LINE, AUTOGEN_EXPLAIN]
    manifest_lines.extend(commands)
    manifest_lines.extend((
            "# TOTAL FILES: %s (%s bytes)" % (intcomma(len(cached_files)), intcomma(size)),
            "# SIGNATURE: %s" % hashlib.sha1('\n'.join(hash_lines)).hexdigest(),
            "CACHE:",
            ))
    manifest_lines.extend(cached_files)

    manifest_file = open(MANIFEST_FILENAME, 'w')
    manifest_file.write('\n'.join(manifest_lines) + '\n')
    manifest_file.close()

    # Make sure the listing for the manifest file is up to date
    # so it will be uploaded if changed.
    update_local_listing(MANIFEST_FILENAME)


